{"name":"shinychord","tagline":"Reusable shiny modules","body":"# shinychord\r\n\r\nThe puropse of this package is to propose a convention for resuable shiny modules.\r\n\r\nThis might be useful for shiny code where:\r\n\r\n- there are a lot of controls that are importatnt only within the module.\r\n- there is a need to use the module in different apps.\r\n\r\nWe give a way to help ensure unique id's for each of the input and output elements.\r\nWe give a way to expose only a few reactive values.\r\n\r\n## tl;dr\r\n\r\n[PDF of a presentation](https://ijlyttle.github.io/shinychord/doc/isu_presentation.pdf) made to the ISU Statistics Graphics Group - 2015-10-01.\r\n\r\n## Structure of a shinychord\r\n\r\nA shinychord is simply a function that takes `id` as its argument. It returns a list with three items:\r\n\r\n- `ui_controller` a `shiny::tagList` containing ui elements focusing on inputs\r\n- `ui_view` a `shiny::tagList` containing ui elements focusing on outputs\r\n- `server_model` a function that contains all the server logic\r\n\r\nAs you might imagine, the names on this list are inspired by the model-view-controller paradigm.\r\n\r\n## Example\r\n\r\nLet's say we wanted a shinychord to upload and parse a delimited file. We start with a template for a shinychord:\r\n\r\n```R\r\nch_upload_parse <- function(id){\r\n\r\n  # controller\r\n  ui_controller <- shiny::tagList()\r\n\r\n  # view\r\n  ui_view <- shiny::tagList()\r\n\r\n  # model\r\n  server_model <- function(\r\n    input, output, session\r\n  ){\r\n  \r\n  }\r\n  \r\n  list(\r\n    ui_controller = ui_controller,\r\n    ui_view = ui_view,\r\n    server_model = server_model\r\n  )\r\n}\r\n```\r\n\r\nOver the next few sections, we show how the parts of the template are filled out so that we end with a complete shinychord.\r\n\r\n### Naming function\r\n\r\nOne of the challenges we have in composing shiny applications is a way to keep the names unique amomg each of the elements.\r\n\r\nTo help us, I put a function at the top of the shinychord:\r\n\r\n```R\r\nid_name <- function(...){\r\n  paste(list(id, ...), collapse = \"_\")\r\n}\r\n```\r\n\r\nThis function will be very handy as we define the inputs and outputs.\r\n\r\n### Controller\r\n\r\nWe could make this as fancy as we like, but let's consider a simple set of controls, comprised of a file-upload input and a select input (to choose a delimiter)\r\n\r\n```R\r\nui_controller <- shiny::tagList()\r\n\r\nid_controller_file <- id_name(\"controller\", \"file\")\r\nui_controller$file <-\r\n  shiny::fileInput(\r\n    inputId = id_controller_file,\r\n    label = \"File\",\r\n    accept = c(\"text/csv\", \".csv\", \"text/comma-separated-values\", \"text/plain\")\r\n  )\r\n```\r\n\r\nYou can see that we use the `id_name()` function to combine the `id` string (supplied as an\r\nargument to the shiny chord) with the local identifier.\r\n\r\nWe also want an input to choose the delimiter:\r\n\r\n```R\r\nid_controller_delim <- id_name(\"controller\", \"delim\")\r\nui_controller$delim <-\r\n  shiny::selectizeInput(\r\n    inputId = id_controller_delim,\r\n    label = \"Delimiter\",\r\n    choices = c(Comma = \",\", Semicolon = \";\", Tab = \"\\t\"),\r\n    selected = \";\"\r\n  )\r\n```\r\n\r\n### View\r\n\r\nWe will want a couple of view elements - one to preview the text that has been uploaded, and another to preview the parsed dataframe.\r\n\r\n```R\r\nui_view <- shiny::tagList()\r\n\r\n# shows the raw text of the file (first few lines)\r\nid_view_text <- id_name(\"view\", \"text\")\r\nui_view$text <- shiny::verbatimTextOutput(id_view_text)\r\n\r\n# shows a glimpse of the parsed data-frame\r\nid_view_data <- id_name(\"view\", \"data\")\r\nui_view$data <- shiny::verbatimTextOutput(id_view_data)\r\n```\r\n\r\n### Model\r\n\r\nA couple of notes here:\r\n\r\n- Whenever we refer to a reactive value, we have to wrap it in a reactive expression.\r\n\r\n- For this shinychord, the ultimate goal is to encapsulate the details so that we expose an `id`, when we create the shinychord, and a reactive value, when we place the `server_model()` function in the shiny `server()` function. We have to pass to this `server_model()` function the reactive value and the name of the item within the reactive value. It will be in this reactive value that the parsed dataframe will be placed.\r\n\r\n```R\r\nserver_model <- function(\r\n  input, output, session,\r\n  rctval_data, item_data\r\n){\r\n\r\n  ## reactives\r\n\r\n  # reactive to read in the raw text from the file-specification input\r\n  rct_txt <- reactive({\r\n\r\n    shiny::validate(\r\n      shiny::need(env$input[[id_controller_file]], \"File not selected\")\r\n    )\r\n\r\n    infile <- input[[id_controller_file]]$datapath\r\n\r\n    readr::read_file(infile)\r\n  })\r\n\r\n  ## observers\r\n\r\n  # this needs to be wrapped in a reactive expression\r\n  observe({\r\n    rctval_data[[item_data]] <-\r\n      readr::read_delim(\r\n        file = rct_txt(),\r\n        delim = input[[id_controller_delim]]\r\n      )\r\n  })\r\n\r\n  ## outputs\r\n\r\n  # sets the output for the raw text\r\n  output[[id_view_text]] <-\r\n    renderText({\r\n      \r\n      shiny::validate(\r\n        shiny::need(rct_txt(), \"File did not load properly\")\r\n      )\r\n      \r\n      h <- rct_txt()\r\n      h <- readr::read_lines(h, n_max = 10)\r\n      \r\n      paste(h, collapse = \"\\n\")\r\n    })\r\n\r\n\r\n  # sets the output for the parsed dataframe\r\n  output[[id_view_data]] <-\r\n    renderPrint({\r\n      \r\n      shiny::validate(\r\n        shiny::need(rctval_data[[item_data]], \"No data\")\r\n      )\r\n      \r\n      dplyr::glimpse(rctval_data[[item_data]])\r\n    })\r\n\r\n}\r\n```\r\n\r\n## Completed shinychord\r\n\r\nSo here are all the elements from above, combined into a shinychord function:\r\n\r\n```R\r\nch_upload_parse <- function(id){\r\n\r\n  id_name <- function(...){\r\n    paste(list(id, ...), collapse = \"_\")\r\n  }\r\n\r\n  # controller\r\n  ui_controller <- shiny::tagList()\r\n\r\n  id_controller_file <- id_name(\"controller\", \"file\")\r\n  ui_controller$file <-\r\n    shiny::fileInput(\r\n      inputId = id_controller_file,\r\n      label = \"File\",\r\n      accept = c(\"text/csv\", \".csv\", \"text/comma-separated-values\", \"text/plain\")\r\n    )\r\n\r\n  id_controller_delim <- id_name(\"controller\", \"delim\")\r\n  ui_controller$delim <-\r\n    shiny::selectizeInput(\r\n      inputId = id_controller_delim,\r\n      label = \"Delimiter\",\r\n      choices = c(Comma = \",\", Semicolon = \";\", Tab = \"\\t\"),\r\n      selected = \";\"\r\n    )\r\n  \r\n  # view\r\n  ui_view <- shiny::tagList()\r\n  \r\n  # shows the raw text of the file (first few lines)\r\n  id_view_text <- id_name(\"view\", \"text\")\r\n  ui_view$text <- shiny::verbatimTextOutput(id_view_text)\r\n  \r\n  # shows a glimpse of the parsed data-frame\r\n  id_view_data <- id_name(\"view\", \"data\")\r\n  ui_view$data <- shiny::verbatimTextOutput(id_view_data)\r\n  \r\n  # model\r\nserver_model <- function(\r\n  input, output, session,\r\n  rctval_data, item_data\r\n){\r\n\r\n  ## reactives\r\n\r\n  # reactive to read in the raw text from the file-specification input\r\n  rct_txt <- reactive({\r\n\r\n    shiny::validate(\r\n      shiny::need(input[[id_controller_file]], \"File not selected\")\r\n    )\r\n\r\n    infile <- input[[id_controller_file]]$datapath\r\n\r\n    readr::read_file(infile)\r\n  })\r\n\r\n  ## observers\r\n\r\n  # this needs to be wrapped in a reactive expression\r\n  observe({\r\n    rctval_data[[item_data]] <-\r\n      readr::read_delim(\r\n        file = rct_txt(),\r\n        delim = input[[id_controller_delim]]\r\n      )\r\n  })\r\n\r\n  ## outputs\r\n\r\n  # sets the output for the raw text\r\n  output[[id_view_text]] <-\r\n    renderText({\r\n      \r\n      shiny::validate(\r\n        shiny::need(rct_txt(), \"File did not load properly\")\r\n      )\r\n      \r\n      h <- rct_txt()\r\n      h <- readr::read_lines(h, n_max = 10)\r\n      \r\n      paste(h, collapse = \"\\n\")\r\n    })\r\n\r\n\r\n  # sets the output for the parsed dataframe\r\n  output[[id_view_data]] <-\r\n    renderPrint({\r\n      \r\n      shiny::validate(\r\n        shiny::need(rctval_data[[item_data]], \"No data\")\r\n      )\r\n      \r\n      dplyr::glimpse(rctval_data[[item_data]])\r\n    })\r\n\r\n}  \r\n  list(\r\n    ui_controller = ui_controller,\r\n    ui_view = ui_view,\r\n    server_model = server_model\r\n  )\r\n}\r\n```\r\n\r\n### Using the shinychord in an app\r\n\r\nHere's where we can see a benefit of this approach, as all the interal complexity of the shinychord has been encapuslated, exposing only the bits we need.\r\n\r\nFor the shiny developer, instead of developing a file-parser for every occasion, or cutting and pasting from a template (and managing the id's), she or he can use a shinychord - set an `id` in one place, and create a reactive value into which the `server_model` function can leave the resulting dataframe.\r\n\r\nThe shinychord function can be created once and used everywhere.\r\n\r\n```R\r\nlibrary(\"shiny\")\r\nlibrary(\"readr\")\r\nlibrary(\"dplyr\")\r\n\r\nchord_parse <- ch_upload_parse(\"parse\")\r\n\r\nshinyApp(\r\n\r\n  ui = fluidPage(\r\n    sidebarLayout(\r\n      sidebarPanel(chord_parse$ui_controller),\r\n      mainPanel(chord_parse$ui_view)\r\n    )\r\n  ),\r\n  \r\n  server = function(input, output, session){\r\n  \r\n    rctval <- reactiveValues(data_csv = NULL)\r\n    \r\n    chord_parse$server_model(\r\n      input, output, session,\r\n      rctval_data = rctval, item_data = \"data_csv\"\r\n    )\r\n    \r\n    observe(print(rctval$data_csv))\r\n    \r\n  }\r\n  \r\n)\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}